package io.sited.db.impl.jdbc;

import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.base.Stopwatch;
import com.google.common.collect.Lists;

import io.sited.StandardException;
import io.sited.db.Entity;
import io.sited.db.Id;
import io.sited.db.impl.jdbc.dialect.DBFuctionFactroy;
import io.sited.db.impl.jdbc.dialect.FuncAdapter;
import io.sited.validator.constraints.NotNull;

/**
 * @author chi
 */
public final class EntitySchemaGenerator {
	private final Logger logger = LoggerFactory.getLogger(EntitySchemaGenerator.class);

	private final Connection connection;
	private final Class<?> entityClass;
	private FuncAdapter sqlUtil;
	private static String sequenceSQL = "";
	private static String triggerSQL = "";

	public EntitySchemaGenerator(Connection connection, Class<?> entityClass) {
		this.connection = connection;
		this.entityClass = entityClass;
		this.sqlUtil = DBFuctionFactroy.getFuncAdapter(connection);
	}

	public void createIfNoneExists() {
		Stopwatch watch = Stopwatch.createStarted();
		String sql = schemeSQL();
		try (PreparedStatement preparedStatement = connection.prepareStatement(sql)) {
			if (!tableExists()) {
				preparedStatement.executeUpdate();
				logger.info("create schema, entityClass={}, sql={}, elapsedTime={}", entityClass.getCanonicalName(),
						sql, watch.elapsed(TimeUnit.MILLISECONDS));

				// Oracle & 主键自增长
				try { // 创建序列
					if (!"".equals(sequenceSQL)) {
						PreparedStatement ps = connection.prepareStatement(sequenceSQL);
						ps.executeUpdate();
						logger.info("create sequence: " + sequenceSQL);
						sequenceSQL = "";
					}
				} catch (Exception e) {
				}
				try { // 创建触发器
					if (!"".equals(triggerSQL)) {
						Statement stmt = connection.createStatement();
						stmt.executeUpdate(triggerSQL);
						logger.info("create trigger: " + triggerSQL);
						triggerSQL = "";
					}
				} catch (Exception e) {
				}
			}
		} catch (SQLException e) {
			throw new StandardException(e);
		}
	}

	private boolean tableExists() throws SQLException {
		DatabaseMetaData databaseMetaData = connection.getMetaData();
		Entity table = entityClass.getDeclaredAnnotation(Entity.class);
		ResultSet resultSet = databaseMetaData.getTables(null, null, null, new String[] { "TABLE" });
		while (resultSet.next()) {
			String tableName = resultSet.getString("TABLE_NAME");
			if (tableName.equalsIgnoreCase(table.name())) {
				return true;
			}
		}
		return false;
	}

	private String schemeSQL() {
		StringBuilder builder = new StringBuilder("CREATE TABLE ");
		Entity table = entityClass.getDeclaredAnnotation(Entity.class);
		builder.append(table.name()).append(" (");

		List<String> primaryKeys = Lists.newArrayList();
		for (Field field : entityClass.getDeclaredFields()) {
			io.sited.db.Field column = field.getDeclaredAnnotation(io.sited.db.Field.class);
			Id id = field.getDeclaredAnnotation(Id.class);

			if (id != null) {
				builder.append("id ");
				builder.append(columnType(field.getType()));

				if (id.autoGenerated()) {
					int currentDBType = sqlUtil.getCurrentDBType();
					if (currentDBType == FuncAdapter.MYSQL) {
						builder.append(" AUTO_INCREMENT");
					} else if (currentDBType == FuncAdapter.MSSQL) {
						builder.append(" IDENTITY");
					} else if (currentDBType == FuncAdapter.IBM_DB2) {
						builder.append(" GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1, NO CACHE)");
					} else if (currentDBType == FuncAdapter.ORACLE) {
						// oracle：建表后创建 1、序列 2、触发器
						sequenceSQL = "CREATE SEQUENCE " + table.name() + "_sequence"
								+ " INCREMENT BY 1 START WITH 1 NOMAXVALUE NOCYCLE NOCACHE";
						triggerSQL = "CREATE or REPLACE TRIGGER " + table.name() + "_trigger BEFORE INSERT ON "
								+ table.name() + " FOR EACH ROW DECLARE ID NUMBER;BEGIN SELECT " + table.name()
								+ "_sequence.nextval INTO ID FROM " + table.name() + ";:NEW.ID:=ID;END " + table.name()
								+ "_trigger;";
					} else {
						// 其他DB暂不支持
					}
				}

				primaryKeys.add("id");
			} else {
				builder.append(column.name()).append(' ');
				builder.append(columnType(field.getType()));

			}

			if (field.isAnnotationPresent(NotNull.class)) {
				builder.append(" NOT NULL");
			}

			builder.append(", ");
		}

		builder.append("PRIMARY KEY(");

		int index = 0;
		for (String primaryKey : primaryKeys) {
			if (index > 0)
				builder.append(", ");
			builder.append(primaryKey);
			index++;
		}

		builder.append("))");

		logger.debug(builder.toString());
		return builder.toString();
	}

	// http://dev.mysql.com/doc/connector-j/en/connector-j-reference-type-conversions.html
	private String columnType(Class<?> fieldClass) {
		int currentDBType = sqlUtil.getCurrentDBType();
		if (Integer.class.equals(fieldClass)) {
			if (currentDBType == FuncAdapter.ORACLE) { // Oracle
				return "NUMBER(10,0)";
			}
			return "INT";
		}
		if (Long.class.equals(fieldClass)) {
			if (currentDBType == FuncAdapter.ORACLE) { // Oracle
				return "NUMBER(20,0)";
			}
			return "BIGINT";
		}
		if (String.class.equals(fieldClass)) {
			int length = 255;
			return "VARCHAR(" + length + ")";
		}
		if (Enum.class.isAssignableFrom(fieldClass)) {
			return "VARCHAR(100)";
		}
		if (Boolean.class.equals(fieldClass)) {
			if (currentDBType == FuncAdapter.IBM_DB2) { // DB2
				return "CHAR(1) FOR BIT DATA";
			}
			if (currentDBType == FuncAdapter.ORACLE) { // Oracle
				return "NUMBER(2)";
			}
			return "BIT(1)";
		}
		if (Double.class.equals(fieldClass)) {
			if (currentDBType == FuncAdapter.MSSQL || currentDBType == FuncAdapter.ORACLE) { // SQL Server、Oracle
				return "FLOAT(24)";
			}
			return "DOUBLE";
		}
		if (BigDecimal.class.equals(fieldClass)) {
			if (currentDBType == FuncAdapter.ORACLE) { // Oracle
				return "FLOAT(24)";
			}
			return "DECIMAL(10,2)";
		}
		if (LocalDateTime.class.equals(fieldClass)) {
			if (currentDBType == FuncAdapter.MSSQL) { // SQL Server
				return "CHAR(19)";
			}
			if (currentDBType == FuncAdapter.ORACLE) { // Oracle
				return "DATE";
			}
			return "TIMESTAMP";
		}
		if (LocalDate.class.equals(fieldClass)) {
			return "DATE";
		}
		throw new StandardException("unsupported field class, class={}", fieldClass.getCanonicalName());
	}
}
